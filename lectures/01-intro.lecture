= Зайци

<img src="01-intro/two-rabbits.jpg" width="90%">

= Още зайци

<img src="01-intro/many-rabbits.jpg" width="90%">

= Как всъщност се въдят зайците

:code
  (def fib (fn [n]
    (if (= n 0)
        1
        (if (= n 1)
            1
            (+ (fib (- n 1)) (fib (- n 2)))))))

  (fib 0)
  ; 0
  (fib 11)
  ; 144

= 90% от синтаксиса
* Списъци и вектори: `()` и `[]`
* Викане на функция: `(+ 16 782163)`
* Може да влагаме на воля: `(/ (fib 65) (- (+ 11 4) 3))`
* Дефиниране на `Var`: `(def stefan "master")`
* Условия: `(if (fresh? lettuce) (salad lettuce) (coprse delivery-boy))`
* `(let [stefan "monster"] (str "Stefan is a " stefan))`
* `(do (println "baba") (println "dyado") "return-value")`
* `(quote (+ 1 2))` или `'(+ 1 2)`
* Функция: `(fn kick-ass [ass] (kick (bleach ass)))`
* Запетаи, кавички, тирета, идентификатори

= fn

:code
  ((fn [a b c d e]
    (+ a b c d e))
  1 2 3 4 5)

= defn

`def` + `fn`

:code
  (defn fib [n]
    (if (= n 0)
        1
        (if (= n 1)
            1
            (+ (fib (- n 1)) (fib (- n 2))))))

= case
:code
  (defn fib [n]
    (case n
      0 1
      1 1
      (+ (fib (- n 1)) (fib (- n 2)))))

= if + няколко неща за правене

:code
  (if (disaster-struck?)
    ((save-laptop) (save-stefan))
    (lick-ice-cream))

Не работи! Ще се опита да използва резултата от `(save-laptop)` като функция и ще му даде като аргумент резултата от `(save-stefan)`.

= do

:code
  (if (disaster-struck?)
    (do
      (save-laptop)
      (save-stefan)
      (save-the-world))
    (lick-ice-cream))

= when

`if` + `do` - `else`

:code
  (when (am-grownup? self)
    (walk-naked)
    (lie-all-day)
    (eat-chocolate-all-day)
    (get-fat-all-day)
    (skip-lectures)
    (live-forever))

  ; when-not
= nil/truthiness

Лъжа са само `false` и `nil`

:code
  (defn truth-level [x] (if x "true" "false"))

  (truth-level 5)
  (truth-level "baba")
  (truth-level "")
  (truth-level '())
  (truth-level [])
  (truth-level true)
  (truth-level false)
  (truth-level nil)
  (truth-level nil false)
= Не е като в Scheme

В Scheme празния списък е `nil`, в Clojure си е просто празен списък.

= arity
Дефиниции за различни на брой аргументи в една:
:code
  (defn call-a-master
    ([] "Stefan is coming to save you!")
    ([name] (str "Bootie-calling " name ". Get ready!")))

= Функциите са първокласни обекти в Clojure.
* Може да ги създаваме когато си поискаме
* Можем да ги държим в стандартните структури от данни
* Може да ги подаваме като аргументи насам-натам
* Може да ги връщаме като резултат от функции

= Функции от по-висок ред

Функция, която или приема като аргумент функция или връща като резултат функция.

:code
  (defn fifth [l]
    (first (rest (rest (rest (rest l))))))
  ; (fifth [1 2 3 4 5]
  ; 5

  (def fifth-comp (comp first rest rest rest rest))
  ; (fifth-comp [1 2 3 4 5]
  ; 5
= Примери
:code
  (map str [1 2 3 4 5])
  ; ("1" "2" "3" "4" "5")

  (filter (complement nil?) [1 false 3 nil 5])
  ; (1 false 3 5)

  (remove #(< % 3) [1 2 3 4 5])
  ; (3 4 5)

  (map #(Math/floor (+ (Math/sqrt %) 11)) [1 2 3 4 5])
  ; (12.0 12.0 12.0 13.0 13.0)

  (map #(+ % 5) [1 2 3 4 5])
  ; (6 7 8 9 10)

  (map (partial + 5) [1 2 3 4 5])
  ; (6 7 8 9 10)
= #
* `#(+ 5 %)`
* `#(< % 3)`
* `#(Math/pow %1 %2)`
* `#(#(+ % %))` – не можем да ги влагаме
* Няма неявно `do`, само един израз

= рекурсията – враг на народа

:code
  (defn pow [base exp]
    (if (zero? exp)
      1
      (* base (pow base (dec exp)))))

  (pow 2 10000)
  ; java.lang.StackOverflowError

Това не е опашкова рекурсия.

= опашати степени

:code
  (defn pow [base exp]
    (letfn [(pow-helper [base exp acc]
              (if (zero? exp)
                acc
                (pow-helper base (dec exp) (* base acc))))]
      (pow-helper base exp 1)))

  (pow 2 (bigint 10000))
  ; java.lang.StackOverflowError

JVM не поддържа оптимизация на опашкова рекурсия.

= recur
:code
  (defn pow [base exp]
    (letfn [(pow-helper [base exp acc]
              (if (zero? exp)
                acc
                (recur base (dec exp) (* base acc))))]
      (pow-helper base exp 1)))

  (pow 2 (bigint 10000))
  ;19950631168807583848837421626835850838234968318861924548520089498529438830221946631919961684036194597899331129423209124271556491349413781117593785932096323957855730046793794526765246551266059895520550086918193311542508608460618104685509074866089624888090489894838009253941633257850621568309473902556912388065225096643874441046759871626985453222868538161694315775629640762836880760732228535091641476183956381458969463899410840960536267821064621427333394036525565649530603142680234969400335934316651459297773279665775606172582031407994198179607378245683762280037302885487251900834464581454650557929601414833921615734588139257095379769119277800826957735674444123062018757836325502728323789270710373802866393031428133241401624195671690574061419654342324638801248856147305207431992259611796250130992860241708340807605932320161268492288496255841312844061536738951487114256315111089745514203313820202931640957596464756010405845841566072044962867016515061920631004186422275908670900574606417856951911456055068251250406007519842261898059237118054444788072906395242548339221982707404473162376760846613033778706039803413197133493654622700563169937455508241780972810983291314403571877524768509857276937926433221599399876886660808368837838027643282775172273657572744784112294389733810861607423253291974813120197604178281965697475898164531258434135959862784130128185406283476649088690521047580882615823961985770122407044330583075869039319604603404973156583208672105913300903752823415539745394397715257455290510212310947321610753474825740775273986348298498340756937955646638621874569499279016572103701364433135817214311791398222983845847334440270964182851005072927748364550578634501100852987812389473928699540834346158807043959118985815145779177143619698728131459483783202081474982171858011389071228250905826817436220577475921417653715687725614904582904992461028630081535583308130101987675856234343538955409175623400844887526162643568648833519463720377293240094456246923254350400678027273837755376406726898636241037491410966718557050759098100246789880178271925953381282421954028302759408448955014676668389697996886241636313376393903373455801407636741877711055384225739499110186468219696581651485130494222369947714763069155468217682876200362777257723781365331611196811280792669481887201298643660768551639860534602297871557517947385246369446923087894265948217008051120322365496288169035739121368338393591756418733850510970271613915439590991598154654417336311656936031122249937969999226781732358023111862644575299135758175008199839236284615249881088960232244362173771618086357015468484058622329792853875623486556440536962622018963571028812361567512543338303270029097668650568557157505516727518899194129711337690149916181315171544007728650573189557450920330185304847113818315407324053319038462084036421763703911550639789000742853672196280903477974533320468368795868580237952218629120080742819551317948157624448298518461509704888027274721574688131594750409732115080498190455803416826949787141316063210686391511681774304792596709376N

= loop
:code
  (defn random-draws [number-of-rounds]
    (println "Initializng…")
    (loop [sum 0 rounds-remaing number-of-rounds]
      (let [random-number (inc (rand-int 6))]
        (println "Current sum: " sum)
        (println "Dice: " random-number)
        (when (> rounds-remaing 0)
          (recur (+ sum random-number) (dec rounds-remaing)))))
    (println "Deinitializing…"))

  (random-draws 4)
