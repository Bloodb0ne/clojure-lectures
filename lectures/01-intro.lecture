= Зайци

<img src="01-intro/two-rabbits.jpg" width="90%">

= Още зайци

<img src="01-intro/many-rabbits.jpg" width="90%">

= Как всъщност се въдят зайците

:annotate
  (def fib (fn [n]
    (if (= n 0)
        1
        (if (= n 1)
            1
            (+ (fib (- n 1)) (fib (- n 2)))))))

  (fib 0)  ; =>
  (fib 11) ; =>

= 90% от синтаксиса

* Списъци и вектори: `()` и `[]`
* Викане на функция: `(+ 16 782163)`
* Може да влагаме на воля: `(/ (fib 65) (- (+ 11 4) 3))`
* Дефиниране на `Var`: `(def stefan "master")`
* Условия: `(if (fresh? lettuce) (salad lettuce) (coprse delivery-boy))`
* `(let [stefan "monster"] (str "Stefan is a " stefan))`
* `(do (println "baba") (println "dyado") "return-value")`
* `(quote (+ 1 2))` или `'(+ 1 2)`
* Функция: `(fn kick-ass [ass] (kick (bleach ass)))`
* Запетаи, кавички, тирета, идентификатори

= fn

:code
  ((fn [a b c d e]
    (+ a b c d e))
   1 2 3 4 5)

= defn

`def` + `fn`

:code
  (defn fib [n]
    (if (= n 0)
        1
        (if (= n 1)
            1
            (+ (fib (- n 1)) (fib (- n 2))))))

= case
:code
  (defn fib [n]
    (case n
      0 1
      1 1
      (+ (fib (- n 1)) (fib (- n 2)))))

= if + няколко неща за правене

:code
  (if (disaster-struck?)
    ((save-laptop) (save-stefan))
    (lick-ice-cream))

Не работи! Ще се опита да използва резултата от `(save-laptop)` като функция и ще му даде като аргумент резултата от `(save-stefan)`.

= do

:code
  (if (disaster-struck?)
    (do
      (save-laptop)
      (save-stefan)
      (save-the-world))
    (lick-ice-cream))

= when

`if` + `do` - `else`

:code
  (when (am-grownup? self)
    (walk-naked)
    (lie-all-day)
    (eat-chocolate-all-day)
    (get-fat-all-day)
    (skip-lectures)
    (live-forever))

  ; when-not

= nil/truthiness

Лъжа са само `false` и `nil`

:annotate
  (defn truth-level [x] (if x "true" "false"))

  (truth-level 5)      ; =>
  (truth-level "baba") ; =>
  (truth-level "")     ; =>
  (truth-level '())    ; =>
  (truth-level [])     ; =>
  (truth-level true)   ; =>
  (truth-level false)  ; =>
  (truth-level nil)    ; =>

= Не е като в Scheme

В Scheme празния списък е `nil`, в Clojure си е просто празен списък.

= arity

Дефиниции за различни на брой аргументи в една:
:code
  (defn call-a-master
    ([] "Stefan is coming to save you!")
    ([name] (str "Bootie-calling " name ". Get ready!")))

= Функциите са първокласни обекти в Clojure.

* Може да ги създаваме когато си поискаме
* Можем да ги държим в стандартните структури от данни
* Може да ги подаваме като аргументи насам-натам
* Може да ги връщаме като резултат от функции

= Функции от по-висок ред

Функция, която или приема като аргумент функция или връща като резултат функция.

:annotate
  (defn fifth [l]
    (first (rest (rest (rest (rest l))))))
  (fifth [1 2 3 4 5])
  ; =>

  (def fifth-comp (comp first rest rest rest rest))
  (fifth-comp [1 2 3 4 5])
  ; =>

= Примери
:annotate
  (map str [1 2 3 4 5])
  ; =>

  (filter (complement nil?) [1 false 3 nil 5])
  ; =>

  (remove #(< % 3) [1 2 3 4 5])
  ; =>

  (map #(Math/floor (+ (Math/sqrt %) 11)) [1 2 3 4 5])
  ; =>

  (map #(+ % 5) [1 2 3 4 5])
  ; =>

  (map (partial + 5) [1 2 3 4 5])
  ; =>

= #

* `#(+ 5 %)`
* `#(< % 3)`
* `#(Math/pow %1 %2)`
* `#(#(+ % %))` – не можем да ги влагаме
* Няма неявно `do`, само един израз

= рекурсията – враг на народа

:annotate
  (defn pow [base exp]
    (if (zero? exp)
      1
      (* base (pow base (dec exp)))))

  (pow (bigint 2) (bigint 10000))
  ; =>

Това не е опашкова рекурсия.

= опашати степени

:annotate
  (defn pow [base exp]
    (letfn [(pow-helper [base exp acc]
              (if (zero? exp)
                acc
                (pow-helper base (dec exp) (* base acc))))]
      (pow-helper base exp 1)))

  (pow (bigint 2) (bigint 10000))
  ; =>

JVM не поддържа оптимизация на опашкова рекурсия.

= recur
:annotate
  (defn pow [base exp]
    (letfn [(pow-helper [base exp acc]
              (if (zero? exp)
                acc
                (recur base (dec exp) (* base acc))))]
      (pow-helper base exp 1)))

  (pow (bigint 2) (bigint 10000))
  ; =>

= loop
:code
  (defn random-draws [number-of-rounds]
    (println "Initializng…")
    (loop [sum 0 rounds-remaing number-of-rounds]
      (let [random-number (inc (rand-int 6))]
        (println "Current sum: " sum)
        (println "Dice: " random-number)
        (when (> rounds-remaing 0)
          (recur (+ sum random-number) (dec rounds-remaing)))))
    (println "Deinitializing…"))

  (random-draws 4)
